<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Model Test - Fixed Scale</title>
    <style>
        body {
            margin: 0;
            background: #1a1a2e;
        }

        canvas {
            display: block;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
        }

        .success {
            color: #44ff44;
        }

        .error {
            color: #ff4444;
        }
    </style>
</head>

<body>
    <div id="info">
        <h3 style="margin-top:0">Model Test (Small Scale)</h3>
        <p>Status: <span id="status">Loading...</span></p>
        <p id="details"></p>
    </div>

    <script src="lib/three.min.js"></script>
    <script src="lib/GLTFLoader.js"></script>

    <script>
        const statusEl = document.getElementById('status');
        const detailsEl = document.getElementById('details');

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);

        // Camera positioned to see a small model (like in AR scene)
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 100);
        camera.position.set(0, 1.5, 4);
        camera.lookAt(0, 0.5, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 5);
        scene.add(dirLight);

        // Grid helper - each square is 1 unit (good for reference)
        const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
        scene.add(gridHelper);

        // Axes helper - 1 unit each axis
        const axesHelper = new THREE.AxesHelper(1);
        scene.add(axesHelper);

        const loader = new THREE.GLTFLoader();
        let model = null;
        let mixer = null;

        // SCALE TO APPLY - model is tiny (0.02 units raw), so scale UP
        const MODEL_SCALE = 1;

        loader.load(
            'content/scene.glb',
            function (gltf) {
                model = gltf.scene;

                // Apply the small scale
                model.scale.set(MODEL_SCALE, MODEL_SCALE, MODEL_SCALE);

                // Center the model
                const bbox = new THREE.Box3().setFromObject(model);
                const center = bbox.getCenter(new THREE.Vector3());
                const size = bbox.getSize(new THREE.Vector3());

                // Move model so its center is at origin, sitting on y=0
                model.position.x = -center.x;
                model.position.z = -center.z;
                model.position.y = -bbox.min.y; // sit on ground

                scene.add(model);

                // Setup animations
                if (gltf.animations.length > 0) {
                    mixer = new THREE.AnimationMixer(model);
                    gltf.animations.forEach((clip) => {
                        mixer.clipAction(clip).play();
                    });
                }

                statusEl.textContent = 'Model loaded!';
                statusEl.className = 'success';
                detailsEl.innerHTML = `
                    <strong>Scale applied:</strong> ${MODEL_SCALE}<br>
                    <strong>Final size:</strong> ${size.x.toFixed(3)} x ${size.y.toFixed(3)} x ${size.z.toFixed(3)}<br>
                    <strong>Animations:</strong> ${gltf.animations.length}<br>
                    <em>Grid squares = 1 unit each</em>
                `;
            },
            function (xhr) {
                statusEl.textContent = 'Loading...';
            },
            function (error) {
                statusEl.textContent = 'Error!';
                statusEl.className = 'error';
                console.error(error);
            }
        );

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            if (mixer) mixer.update(clock.getDelta());
            if (model) model.rotation.y += 0.005;
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>